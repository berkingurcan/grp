{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1433123510052839000,"abi":{"parameters":[{"name":"lat_point","type":{"kind":"field"},"visibility":"private"},{"name":"lng_point","type":{"kind":"field"},"visibility":"private"},{"name":"polygon_vertices_x","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"polygon_vertices_y","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"result","type":{"kind":"boolean"},"visibility":"public"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"H4sIAAAAAAAA/+WdbXdVVxHH/0l4Ck9CIZTyUB6sra1Yzrn3JvdewUpsi4UiWAtFsLYkJIEiiK21tRULRRBtAV/4whe6XMsu1/Jb+NrlW7+CH0R2ujfdOecSFuzfnJw0sxbdNAfm/uc/s2f2PjPt7dPn8tmdX//1v++782vAr8v9usg/61dZ+vy6z69ZmuR9nK6sB9yH1Z0XfxBzscKvK4sEugf/KvxsZQQiyEAauBLYmMRmNtJqTbYbk3kzH8sa3fHOcNYaHh/p5J18uDM80eg0m5OdVqfdHe+2s27Wak7mU8Pd5pTXteLhdeUFXdlKzsZskeezT2UpBmUq7hWz4H5Q3THeVZaAnfL++wTWg37OKs6B+WrQXisOV+v+Ge5BP2e12AxH273S232/2LmfFPWS/v4KyGGcnJ3eUVVb8UBdlVW8NX5dGwgJBLoHxYq3VvYVL9aVWvHWiAvUtZqfFW+NbCreI5aAnXK64j3COTBfp3pXPMfhOvEVb53qXfHWervpikf6e71sKp7TW3XFW6L5V/GG/LohEBIIdA+KFW+D7CteTGJqxRsSF6gbND8r3pBsKt6jloCdcrriPco5MN+oelc8x+FG8RVvo+pd8TZ4u+mKR/r7MdlUPKf3fhUvlZeC5CtViwRbqnA9TDepnpv8ulmaWSk36YsMH362WeXquSgNXAmslUNSK/EmENdm0JlVHg+Xik2eRaE4ibnY4tetgZAQzO5B8Xi4VfbHw6XignKLuKDcytlY6fFwi2yOh49bAnbK6ePh45wD822gvVYcbhN/PNwmNsPRdm/1dtPHQ9Lf20EO4+Ts9M7n42FCgp2z4+EOv+6UZlbKHSofD3dqfh0Pt4qrxDtAXDvhQKGT0Cbvf3qzkUfsr6reidyKQzIOn4A5DDIAcwm+tU45nZdwfQ3k70FO1Fma5CTuGO+TloCfNND7FBgMVnY/FREM6TVJeC4hu4RCX6fBRJ8/Adr7ddkkz37YL2SMPw36YraER3NgVUCyRIltf8ZxQScQF6RPRx9CAZf4BLIkkADr/aOx3VmaTAfUMwZB/w0QY905DHFOx86umtvtfLxrYdk91Wq0phOnxZ75JoiR3jNB6NtVPxiPAyCuZ0H+er1SLMZko90dabY77anxkbzdzbPGZKPZzsbG8pGxvDvRbDUmO+1me6p9emxifLI5dceK5kR2OhtvtruN1vjUpIudZ8XvcdA/lb1W3B10BqLDK0T3oNiUyyIQVk6hbyWxU1JfLe4Wt2kysZumqibfbtk0+XJLwE453eTLOQfmDdBeKw4b4pt8DdmeXohN2hDf5CP93QQ5jJO90zuqapt8a1WLBDtnTb6WX4elmZW3pXKTb1j2TT4rh6RW4haIaxh0ZpUzYMvEJs+iUJzEXIz4tR0ICcHsHhSPm22VA5w+Hi4TF5Qj4oKyzdlY6fFwRDbHw44lYKecPh52OAfmXdBeKw674o+HXbEZjra77e2mj4ekv78FchgnZ6d3Ps+AJSTYOTse7vHrXmlmpdyj8vFwr+yPh1YOSa3Ee0Bce+FAoZPQDu9/erOR80vfVr0TuRWHZBw+B3MYhO5SgG33lNN5Cdd3QP6qnAEjccd491kDpvWOgsFgZfdoD4KzROmFlUjILqHQ12kw0efPgfZ+VzbJk25rkzH+POiLKmfArApIliix7S/IYAbMBenz0YdQwCU+gSwNJMB6/2Rsd5Ym0wH1gkHQvwhirDuHIc7p2Nlfc7udj/cvLLvvzoBZ7JnvgRjpPROEvl0NiC3qFK6XQP6qmAFzsfOS+D0O+qey14oH/HowEB1eIboHxabcwQiElVPoW0nCsGPp1eIBcZvmoNhNU1WT74BsmnwvWwJ2yukm38ucA/NDoL1WHB4S3+Q7JNvTC7FJD4lv8pH+/j7IYZzsnd6qm3zkyFFCgp2zJt9hvx6RZlbewyo3+Y7Ivsln5ZDUSnwYxHUEDhSLK56zl95s+0GMP1C9E7n7T6VaBhzuAjG+AuLqxWGWJvm94pB8hZGq64fGHC6EOHyVw1XpTOyg2BxUlIfUPWvBP+rXY4GQUNzdg+L1+5jKBZ++Lg+KK9JHxQXlMbFBWdV1+ahsrsuvWQJ2yunr8mucA/PjoL1WHB4Xf10+LjbD0XYf83bT12XS3z8COYyTs9M7n2diExLsnF2XT/j1pDSzUp5Q+bp8UvbXZSuHpFbiEyCuk3Cg0Eloj/c/vdnIec4fq96J3IpDMg5fhzkMQndtwTGklNN5CddPQP6qnIklccd437AE/IaB3jfBYLCy+82IYEivScJzCdklFPo6DSb6/HXQ3lOySZ70u0EyxsdAX1Q5E2tVQLJEiW0fl8FM7Kk7OsaiD6GAS3wCWRZIgPX+2djuLE2mA2rcIOhPgxjrzuEpH+d07EzU3G7n44mFZffdmViLPTMJYqT3TBD6drUIjMfFIK4pkL8qZmJd7EyJ3+Ogfyp7rXjGr2cD0eEVontQbMqdjUBYOYW+lSQMf5deLZ4Rt2nOit00VTX5zsimyfeWJWCnnG7yvcU5MD8H2mvF4TnxTb5zsj29EJv0nPgmH+nvn4Icxsne6R3V/J2JTUiwc9bkO+/XC9LMynte5SbfBdk3+awcklqJz4O4LsCBQh8r3bzpK+KT219km3yzNMndfOOrBnb/FbY7CH3d+xnIJejrHOTPZO7UvRJx+YEuThMgxouq995zsXfRwDc/l81hxendrplCv3K6COp6G95DQegc9I6+9DnI7Ms26z5U8osFyiH5pa/vqpqzRJYm+RLQZnIw55cgf1UO5pC4Y7zvWQJ+z0Dv+2AwWNn9fkQwpNck4bmE7BIKvfnBRJ+/C9r7K9kkT/rgR8b4B6AvHmQwJ0sTswKSJUps+4cyGMxxQfpB9CEUcIlPIIOBBFjv34ztztJkOjg/FL/xfw1irDuHIc7p2LlUc7udjy8tLLvvDuZY7JnfgBjpPROkRt+9WOKPHMz5COSvisEcFzsfid/ji43iSGk4Z20FXvbrlUB0eNXpHhQHc67IbjAnOIXeNAmBXmoHXha3aa6I3TRVDeZcls1gzseWgJ1yejDnY86B+VXQXisOr4ofzLkq29MLsUmvih/MIf39W5DDONk7vaOav4M5V8RVzB6mm1Tja369Ls2svNdUHsy5HoEIUufBnCviKvE1ENd1OFDmS5P877JNvlma5K55/Y6B3Z/Bdgehm+K/A7kEfZ2D/JkM5rhXIi4/0MXpEojxhuq991zs3TDwze9lc1hxerdrptCvnG6Auv4A76EgdA76RF/6HNTzlROdO1zskPncxc8nEV6KC/UQSHcj5vdTv950/4g3snuwrfCzm/oiEdGOCYmOdgyVfCanPpdPxW3qm2I3T1XTMDdBDmK8tywB3xJfiW6BGG+DuKw4vC3+JHJbNlmT9vVyI19nieL8ESrn8sj+Ps/BgH/u3r+7xrn7hjv3f/QYjHy5vAdvTv7h16H/jT729n/++WL0SP++x7Pw95f5dbDwGaGg7GPsbwT9K2z0T38jYFFivlYUngX7F/X4e333+Pf+wjrbn50twa/q8SzoXOfXGG+wY7CwDkV6yW/mCvrX2+jv6auh6PfrC3bGfO+DMAR94QawWGXpLzwLf7a4Z/p4fHkRy0CPzwoSYmZ99LPA5/8BFc9INELGAAA=","debug_symbols":"zZ3LThtBEEX/ZdYsuqpfVfxKhJABgyxZBhkTKUL59xjkjqxxMrNw39HdYdzhnEXS4zldEz6Hp/XDx8v9Zvf8+j7c/vgctq+Pq8PmdXd89TnI97fe31a7r1fvh9X+MNyKaroZ1runry9Nf98Mz5vtergtxy8vF7uUttjT2eL4j8VV7LS2ajlfenczKI9K5FFJPCqZR6XwqFQeFeNRcR4VCVe7xCRyWhxTkmkXq/G01kzGLkLkokQukcglEblkIpdC5FKJXIzIZeF9t7i2fTeE8ee5QOQiRC5K5BKJXBKRSyZyKUQulchl6Y+78a9Lurh3dR6XGIhchMilx75r4bRYQ5hxyaVdp3MdX6djJHJJRC6ZyKUQuVQiFyNycR6XFIhcZGGXWpuLj6/TSYlcIpFLInK5ft/VqO3aqzH5GFDQgOt3SLXSPmmomY4BhgY4GJADGiBogKIBHTqkpLYvR7HxP7Sc0ICMBhQ0oKIBHYKdxva3KGq+OChzMKAsfaSR2qXDch67CJGLErlEIpdE5JKJXAqRSyVyMSIXX9jFmotfJMcaiFyEyEWJXIjSWk1ELkRprRKltUqU1ipRWqtEac2I0poJkQtRWjOitGaJyCUTuaArnFU0AF3hDF3hHF3hHF3hHF3hPKIB1+8P04nJ0RXO0RXO0RXODQ1AVzgJAU4gimsSiOqaBKK8JiExyRAFNglEhU0CUWKTQNTYJDiRjBBVNhGizCZC1Nlk8Wc2JmU67MA5tMUxS7ogZDihwAkVTiAqWCJECUuUqGGJEkUsUaLBXFGi4wPp8khENxmiAwRRohME0aWPECYSn6gxyTiRTAxMMh0q3WQplQ7PO8wR0J1OOjybMEfIcEKBEyqcYHBChzvQyRwoHebz5wgCJyicEOGEDrdq09W0wzT7HIEpayWmrJWYslZiylqZaGhXMtPBQmY6WMhMBws9HhfoJ7P0wcJU8MuFSaYyyRiTTIcdeLo49ngWYoYgcILCCRFOSHACvMAXeIEv6AEp6TC7P0dAj0hJDXCCwAkKJ8DzS4f59TkCelBKaoETKpxgcAI8vxh8WKrDZPYcgelGxZhuVDpMXHeUYZqAMqZUZEypyJhSkTGlImdKRc40AeVME1DONAHliUkGfqvm8Fs1hw9L9RiBnyGg84uGACcInKBwQoedouT2f5zHUuoFIcEJGU4ocELtS6h6QTA4wdGE/w1ge26EqOGccHd88bDfbLebl/vzXy9y/PbP1X6zetiuTy+fP3aPZ+8efr21d9qff9u/Pq6fPvbrr5/0/d7xx/8B","file_map":{"62":{"source":"mod point_in_polygon;\n\n// Main circuit function for location verification\n// Input:\n// - lat_point, lng_point: User's GPS coordinates (private)\n// - polygon_vertices: Array of polygon vertex coordinates (public)\n// - result: Boolean indicating if the point is inside the polygon (public)\nfn main(\n    lat_point: Field,\n    lng_point: Field,\n    polygon_vertices_x: [Field; 4],\n    polygon_vertices_y: [Field; 4],\n    result: pub bool\n) {\n    // Convert the user's coordinates to a Point\n    let user_point = point_in_polygon::Point {\n        x: lat_point,  // Already in fixed-point format\n        y: lng_point   // Already in fixed-point format\n    };\n    \n    // Create the polygon from the vertex arrays\n    let mut polygon: [point_in_polygon::Point; 4] = [\n        point_in_polygon::Point { x: 0, y: 0 },\n        point_in_polygon::Point { x: 0, y: 0 },\n        point_in_polygon::Point { x: 0, y: 0 },\n        point_in_polygon::Point { x: 0, y: 0 }\n    ];\n    \n    for i in 0..4 {\n        polygon[i] = point_in_polygon::Point { \n            x: polygon_vertices_x[i], \n            y: polygon_vertices_y[i] \n        };\n    }\n    \n    // Verify the location without revealing the exact coordinates\n    let computed_result = point_in_polygon::is_point_in_polygon(user_point, polygon);\n    assert(computed_result == result);\n}\n\n#[test]\nfn test_location_verification() {\n    // Square with corners at (1,1), (1,3), (3,3), (3,1)\n    let polygon_x = [1_000_000, 1_000_000, 3_000_000, 3_000_000];\n    let polygon_y = [1_000_000, 3_000_000, 3_000_000, 1_000_000];\n    \n    // Test with a point inside the polygon\n    let inside_lat = 2_000_000; // 2.0 in fixed-point\n    let inside_lng = 2_000_000; // 2.0 in fixed-point\n    main(inside_lat, inside_lng, polygon_x, polygon_y, true);\n    \n    // Test with a point outside the polygon\n    let outside_lat = 4_000_000; // 4.0 in fixed-point\n    let outside_lng = 2_000_000; // 2.0 in fixed-point\n    main(outside_lat, outside_lng, polygon_x, polygon_y, false);\n}\n","path":"/Users/berkingurcan/grp/src/main.nr"},"63":{"source":"// Ray Casting Algorithm for Point-in-Polygon\n// This algorithm determines whether a point is inside a polygon\n// by counting the number of times a ray from the point crosses the polygon boundary\n\n// Define a Point structure for GPS coordinates\npub struct Point {\n    pub x: Field,  // Latitude (fixed-point)\n    pub y: Field,  // Longitude (fixed-point)\n}\n\n// Helper functions for comparing Fields by handling internal constraints in Noir\nfn is_lt(a: Field, b: Field) -> bool {\n    // Convert to integers for comparison\n    let a_int = a as u64;\n    let b_int = b as u64;\n    a_int < b_int\n}\n\nfn is_lte(a: Field, b: Field) -> bool {\n    // Convert to integers for comparison\n    let a_int = a as u64;\n    let b_int = b as u64;\n    a_int <= b_int\n}\n\nfn is_gt(a: Field, b: Field) -> bool {\n    // Convert to integers for comparison\n    let a_int = a as u64;\n    let b_int = b as u64;\n    a_int > b_int\n}\n\nfn is_gte(a: Field, b: Field) -> bool {\n    // Convert to integers for comparison\n    let a_int = a as u64;\n    let b_int = b as u64;\n    a_int >= b_int\n}\n\n// Function to check if a point is inside a polygon using Ray Casting Algorithm\n// Returns true if the point is inside the polygon, false otherwise\npub fn is_point_in_polygon(point: Point, polygon: [Point; _]) -> bool {\n    let n = polygon.len();\n    \n    // If polygon has less than 3 vertices, point cannot be inside\n    let mut inside = false;\n    \n    if n >= 3 {\n        // Count the number of intersections\n        let mut count = 0;\n        \n        for i in 0..n {\n            // Get current vertex and next vertex (wrapping around to first vertex)\n            let current = polygon[i];\n            let next = polygon[(i + 1) % n];\n            \n            // Check if the ray from the point to the right intersects with this edge\n            \n            // Check if point.y is between current.y and next.y\n            let current_y_lte_point_y = is_lte(current.y, point.y);\n            let point_y_lt_next_y = is_lt(point.y, next.y);\n            let next_y_lte_point_y = is_lte(next.y, point.y);\n            let point_y_lt_current_y = is_lt(point.y, current.y);\n            \n            let y_in_range_1 = current_y_lte_point_y & point_y_lt_next_y;\n            let y_in_range_2 = next_y_lte_point_y & point_y_lt_current_y;\n            let y_in_range = y_in_range_1 | y_in_range_2;\n            \n            if y_in_range {\n                // Calculate the x-coordinate of the intersection point\n                // Using the equation: x = current.x + (point.y - current.y) * (next.x - current.x) / (next.y - current.y)\n                \n                let y_diff = point.y - current.y;\n                let edge_x_diff = next.x - current.x;\n                let edge_y_diff = next.y - current.y;\n                \n                // Avoid division by zero (when edge is horizontal)\n                if edge_y_diff != 0 {\n                    // Fixed-point multiplication and division\n                    // We're using a SCALE_FACTOR of 1_000_000 (defined in fixed_point.nr)\n                    let SCALE_FACTOR = 1_000_000;\n                    \n                    let factor = (y_diff * SCALE_FACTOR) / edge_y_diff;\n                    let intersection_x = current.x + (factor * edge_x_diff) / SCALE_FACTOR;\n                    \n                    // If intersection is to the right of the point, count it\n                    let is_to_right = is_gt(intersection_x, point.x);\n                    if is_to_right {\n                        count += 1;\n                    }\n                }\n            }\n        }\n        \n        // If count is odd, point is inside polygon\n        inside = count % 2 == 1;\n    }\n    \n    inside\n}\n\n#[test]\nfn test_point_in_polygon() {\n    // Test with a simple square polygon\n    // Coordinates are scaled by SCALE_FACTOR (1,000,000)\n    \n    // Square with corners at (1,1), (1,3), (3,3), (3,1)\n    let polygon = [\n        Point { x: 1_000_000, y: 1_000_000 },\n        Point { x: 1_000_000, y: 3_000_000 },\n        Point { x: 3_000_000, y: 3_000_000 },\n        Point { x: 3_000_000, y: 1_000_000 }\n    ];\n    \n    // Test point inside: (2,2)\n    let inside_point = Point { x: 2_000_000, y: 2_000_000 };\n    assert(is_point_in_polygon(inside_point, polygon));\n    \n    // Test point outside: (4,2)\n    let outside_point = Point { x: 4_000_000, y: 2_000_000 };\n    assert(!is_point_in_polygon(outside_point, polygon));\n    \n    // Test point on boundary: (1,2)\n    let boundary_point = Point { x: 1_000_000, y: 2_000_000 };\n    assert(is_point_in_polygon(boundary_point, polygon));\n}","path":"/Users/berkingurcan/grp/src/point_in_polygon.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}